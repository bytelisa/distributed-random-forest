
# implements the interface of the Worker Service as per defined in .proto file


import time
from concurrent import futures
import grpc

# Import files generated by Protobuf
from api.proto.worker.v1 import worker_pb2
from api.proto.worker.v1 import worker_pb2_grpc
from services.worker.ml import model

# Note: all functions take and return objects defined in the two generated _pb2.py files,
# which implement the interface worker.proto in python.


class WorkerService(worker_pb2_grpc.WorkerServicer):

    def Train(self, request, context):

        print(f"[Worker] Received training request for model {request.model_id}.")
        print(f"        Dataset: {request.dataset_url}")
        print(f"        Trees: {request.n_estimators}")
        print(f"        Task: {worker_pb2.TaskType.Name(request.task_type)}")

        # time.sleep(2)

        my_dataframe = model.load_dataset(request.dataset_url)
        serialized_model = model.train_model(my_dataframe)

        if serialized_model is None:
            print(f"[Worker] Training failed for model {request.model_id}.")
            return worker_pb2.TrainResponse(
                success=False,
                message="Training failed for model {request.model_id}."
            )

        return worker_pb2.TrainResponse(
            success=True,
            message="Training completed. (fake)",
        )


    def Predict(self, request, context):

        print(f"[Worker] Received prediction request for model {request.model_id}.")

        #fake prediction
        #here I should call model.predict_with_model
        return worker_pb2.PredictResponse(value=0.0)


    def Health(self, request, context):

        # Helath check: master wants to know if worker is active
        print("[Worker] Health check received.")
        return worker_pb2.HealthResponse(healthy=True)


